/*$file${.::bsp.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: blinky_console.qm
* File:  ${.::bsp.c}
*
* This code has been generated by QM 5.2.1 <www.state-machine.com/qm>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* SPDX-License-Identifier: GPL-3.0-or-later
*
* This generated code is open source software: you can redistribute it under
* the terms of the GNU General Public License as published by the Free
* Software Foundation.
*
* This code is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
* more details.
*
* NOTE:
* Alternatively, this generated code may be distributed under the terms
* of Quantum Leaps commercial licenses, which expressly supersede the GNU
* General Public License and are specifically designed for licensees
* interested in retaining the proprietary status of their code.
*
* Contact information:
* <www.state-machine.com/licensing>
* <info@state-machine.com>
*/
/*$endhead${.::bsp.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/* Board Support Package implementation for desktop OS (Windows, Linux, MacOS) */
#include <stdio.h>  /* for printf()/fprintf() */
#include <stdlib.h> /* for exit() */
#include <stdbool.h>

#include "qpc.h"    /* QP/C framework API */
#include "bsp.h"    /* Board Support Package interface */
#include "bsp_led.h"
#include "bsp_motors.h"
#include "bsp_buzzer.h"
#include "bsp_adc_fake.h"
#include "bsp_gpio_fake.h"
#include "bsp_gpio.h"
#include "bsp_gpio_mapping.h"
#include "bsp_eeprom.h"

#if defined (RADIO_MODE_PPM)
#include "bsp_ppm_fake.h"
#elif defined (RADIO_MODE_UART) || defined (RADIO_MODE_UART_CRSF)
#include "bsp_uart_fake.h"
#include "bsp_uart.h"
#endif 


#ifdef Q_SPY

#include "qs_defines.h"
static QSpyId const l_clock_tick = { QS_AP_ID };

#endif


uint8_t ble_data[20];


void BSP_init(void)   {
    printf("SumoHSM;  QP/C version: %s\r\n",  QP_VERSION_STR);

    BSP_ledInit();
    BSP_motorsInit();
    BSP_buzzerInit();
    // BSP_radioInit();
   

    #ifdef Q_SPY

    QS_INIT((void *)0);
    
    QS_FUN_DICTIONARY(&QHsm_top);
    QS_OBJ_DICTIONARY(&l_clock_tick);
    QS_USR_DICTIONARY(SIMULATOR);

    /* setup the QS filters... */
    QS_GLB_FILTER(QS_ALL_RECORDS);
    QS_GLB_FILTER(-QS_QF_TICK);

    #endif

}


/* callback functions needed by the framework ------------------------------*/
void QF_onStartup(void) {
    QF_setTickRate(BSP_TICKS_PER_SEC, 50); /* desired tick rate/ticker-prio */
}
void QF_onCleanup(void) {}
void QF_onClockTick(void) {
    QF_TICK_X(0U, (void *)0); /* QF clock tick processing for rate 0 */

    #ifdef Q_SPY
    QS_RX_INPUT(); /* handle the QS-RX input */
    QS_OUTPUT();   /* handle the QS output */
    #endif

}
void Q_onAssert(char const * const module, int loc) {
    fprintf(stderr, "Assertion failed in %s:%d", module, loc);
    exit(-1);
}

#ifdef Q_SPY
/*..........................................................................*/
/*! callback function to execute user commands */
void QS_onCommand(uint8_t cmdId,
                  uint32_t param1, uint32_t param2, uint32_t param3)
{
    switch (cmdId) {
       case 0: { 
            BSP_GPIO_Write_Pin(IO_PORTB, IO_PIN_2 , true);
            break;
        }
        case 1: { 
            BSP_GPIO_Write_Pin(IO_PORTB, IO_PIN_2 , false);
            break;
        }

        case 2: { 
            // BSP_GPIO_Write_Pin(GPIO_BUTTON_PORT, GPIO_BUTTON_PIN , true);
            HAL_Fake_GPIO_EXTI_Callback(GPIO_BUTTON_PIN);
            break;
        }

        case 3: { 
            // When seeing line, real sensor responds with 0
            bool sensor_line_fl = !((param1 & 8) >> 3);
            bool sensor_line_fr = !((param1 & 4) >> 2);
            bool sensor_line_bl = !((param1 & 2) >> 1);
            bool sensor_line_br = !((param1 & 1));

            bool battery_full = param2;

            ADC_Fake_ConvCpltCallback(sensor_line_fl, sensor_line_fr, sensor_line_bl, sensor_line_br, battery_full);

            break;
        }

        case 4: { 

            static uint8_t last_sensor_updated;

            uint8_t sensor_pin = param1;

            if (sensor_pin != 0){
                BSP_GPIO_Write_Pin(IO_PORTA, sensor_pin , true);
                HAL_Fake_GPIO_EXTI_Callback(sensor_pin);
            } 

            BSP_GPIO_Write_Pin(IO_PORTA, last_sensor_updated, false);
            HAL_Fake_GPIO_EXTI_Callback(last_sensor_updated);

            last_sensor_updated = sensor_pin;
            break;
        }

        case 5: { 
            break;
        }

        case 6: { 
            break;
        }

        case 7: { 
            int16_t radio_ch1_val = param1;
            int16_t radio_ch2_val = param2;


            #if defined (RADIO_MODE_PPM)
            fake_ppm_exti_callback(0, radio_ch1_val);
            fake_ppm_exti_callback(1, radio_ch2_val);
            #elif defined (RADIO_MODE_UART) || defined (RADIO_MODE_UART_CRSF)
            int16_t data[4] = {0, radio_ch1_val, radio_ch2_val, 0};
            HAL_UART_Fake_UartData(UART_NUM_4, data);
            #endif 

            break;
        }

        case 8: { 
            int16_t radio_ch3_val = param1;
            int16_t radio_ch4_val = param2;
            int16_t radio_ch6_val = param3;


            #if defined (RADIO_MODE_PPM)
            fake_ppm_exti_callback(2, radio_ch3_val);
            fake_ppm_exti_callback(3, radio_ch4_val);
            #elif defined (RADIO_MODE_UART) || defined (RADIO_MODE_UART_CRSF)
            int16_t data[4] = {1, radio_ch3_val, radio_ch4_val, radio_ch6_val};
            HAL_UART_Fake_UartData(UART_NUM_4, data);
            #endif 


            break;
        }

        /* Update First 12 bytes of BLE */
        case 9: {

            for (int i = 0; i < 4; i++) {
                ble_data[i + 0] = (param1 >> (8 * (3 - i)) & 0xff);
            }

            for (int i = 0; i < 4; i++) {
                ble_data[i + 4] = (param2 >> (8 * (3 - i)) & 0xff);
            }

            for (int i = 0; i < 4; i++) {
                ble_data[i + 8] = (param3 >> (8 * (3 - i)) & 0xff);
            }

            break;
            
        }

        /* Update Last 8 bytes of BLE */
        case 10: {

            for (int i = 0; i < 4; i++) {
                ble_data[i + 12] = (param1 >> (8 * (3 - i)) & 0xff);
            }

            for (int i = 0; i < 4; i++) {
                ble_data[i + 16] = (param2 >> (8 * (3 - i)) & 0xff);
            }

            break;
            
        }

        /* Generate BLE interrupt */
        case 11: {
            
            HAL_UART_Fake_UartData(UART_NUM_3, (int16_t *) ble_data);

            break;
        }

       default:
           break;
    }

    /* unused parameters */
    (void)param1;
    (void)param2;
    (void)param3;
}
#endif
